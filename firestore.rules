rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isSignedIn() {
      return request.auth != null;
    }
    function isOwner(uid) {
      return isSignedIn() && request.auth.uid == uid;
    }
    function isAdmin() {
      // Note: Admin check simplified - in production, use custom claims
      return isSignedIn() && false; // Disabled for now - implement with custom claims
    }
    function isModeratorOfCommunity() {
      // Check if user is in modUids array - uses resource.data from match context
      return isSignedIn() && 
        request.auth.uid in resource.data.modUids;
    }

    // Users: self-write; public read
    match /users/{uid} {
      allow read: if true;
      allow create: if isSignedIn();
      allow update, delete: if isOwner(uid);
    }

    // Communities: public read; create if signed-in; update/delete by admin or moderator
    match /communities/{cid} {
      allow read: if true;
      allow create: if isSignedIn();
      // Allow users to update memberCount when joining/leaving (only increment/decrement by 1)
      // Also allow admins and moderators to update any field
      allow update: if isSignedIn() && 
        ((request.resource.data.memberCount == resource.data.memberCount + 1 ||
          request.resource.data.memberCount == resource.data.memberCount - 1) &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['memberCount'])) ||
        isAdmin() || isModeratorOfCommunity();
      allow delete: if isAdmin() || isModeratorOfCommunity();

      // members subcollection
      match /members/{memberUid} {
        allow read: if true;
        allow create: if isOwner(memberUid) || (isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/communities/$(cid)).data.modUids);
        allow update, delete: if isOwner(memberUid) || (isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/communities/$(cid)).data.modUids);
      }
    }

    // Posts collection
    match /posts/{pid} {
      allow read: if true;
      allow create: if isSignedIn();
      // Allow users to update score and hotRank when voting (only small changes allowed)
      // Also allow author/admin to update/delete
      allow update: if isSignedIn() && (
        (request.resource.data.authorUid == request.auth.uid || isAdmin()) ||
        // Allow score/hotRank updates for voting (validate reasonable changes: -2 to +2)
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['score', 'hotRank']) &&
         request.resource.data.score is int &&
         resource.data.score is int &&
         (request.resource.data.score - resource.data.score) >= -2 &&
         (request.resource.data.score - resource.data.score) <= 2)
      );
      allow delete: if isSignedIn() && (request.resource.data.authorUid == request.auth.uid || isAdmin());

      // Comments subcollection
      match /comments/{cid} {
        allow read: if true;
        allow create: if isSignedIn();
        // Allow users to update score when voting (similar to posts)
        allow update: if isSignedIn() && (
          (request.resource.data.authorUid == request.auth.uid || isAdmin()) ||
          // Allow score updates for voting (validate reasonable changes: -2 to +2)
          (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['score']) &&
           request.resource.data.score is int &&
           resource.data.score is int &&
           (request.resource.data.score - resource.data.score) >= -2 &&
           (request.resource.data.score - resource.data.score) <= 2)
        );
        allow delete: if isSignedIn() && (request.resource.data.authorUid == request.auth.uid || isAdmin());
      }
    }

    // Votes: allow authenticated users to write their own votes
    match /votes/{docId} {
      allow read: if true;

      match /userVotes/{uid} {
        allow read: if true; // Allow reading any user's vote (for display)
        // Allow users to write only their own vote
        allow create, update: if isSignedIn() && isOwner(uid) && 
          request.resource.data.value is int &&
          request.resource.data.value in [-1, 0, 1];
        allow delete: if isSignedIn() && isOwner(uid);
      }
    }

    // Reports
    match /reports/{rid} {
      allow read: if isAdmin();
      allow create: if isSignedIn();
      allow update, delete: if isAdmin();
    }

    // Notifications: only owner may read/write
    match /notifications/{uid} {
      allow read, write: if isOwner(uid);
      match /items/{nid} {
        allow read, write: if isOwner(uid);
      }
    }

    // Conversations: users can only read/write conversations they participate in
    match /conversations/{conversationId} {
      function isParticipant() {
        return isSignedIn() && 
          request.auth.uid in resource.data.participantUids;
      }
      
      // Allow read if user is a participant
      // For list queries, Firestore evaluates this per document
      allow read: if isParticipant();
      
      allow create: if isSignedIn() && 
        request.resource.data.participantUids.size() == 2 &&
        request.auth.uid in request.resource.data.participantUids;
      
      allow update: if isParticipant() &&
        // Only allow updating metadata fields
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastMessage', 'lastMessageAt', 'lastMessageFrom', 'updatedAt']);
      
      allow delete: if false; // Don't allow deletion

      // Messages: users can only read/write messages in conversations they participate in
      match /messages/{messageId} {
        function isConversationParticipant() {
          let convData = get(/databases/$(database)/documents/conversations/$(conversationId)).data;
          return isSignedIn() && 
            convData != null &&
            request.auth.uid in convData.participantUids;
        }
        
        allow read: if isConversationParticipant();
        
        allow create: if isSignedIn() && 
          isConversationParticipant() &&
          request.resource.data.senderUid == request.auth.uid;
        
        allow update: if isSignedIn() &&
          isConversationParticipant() &&
          // Only allow updating read/delivered/seen status fields
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read', 'delivered', 'deliveredAt', 'seen', 'seenAt']);
        
        allow delete: if false; // Don't allow deletion
      }
    }
  }
}
